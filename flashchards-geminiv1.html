<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Concept Learning Flashcards</title>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');

        body {
            font-family: 'Inter', sans-serif;
            background-color: #f3f4f6;
            overscroll-behavior-y: none;
            /* Prevents pull-to-refresh interfering with swipes */
        }

        .perspective-1000 {
            perspective: 1000px;
        }

        .transform-style-3d {
            transform-style: preserve-3d;
        }

        .backface-hidden {
            backface-visibility: hidden;
        }

        .rotate-y-180 {
            transform: rotateY(180deg);
        }

        /* Prevent text selection while swiping */
        .no-select {
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }

        /* Custom scrollbar for card content if needed */
        .card-content::-webkit-scrollbar {
            width: 6px;
        }

        .card-content::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 4px;
        }

        .card-content::-webkit-scrollbar-thumb {
            background: #d1d5db;
            border-radius: 4px;
        }

        .card-content::-webkit-scrollbar-thumb:hover {
            background: #9ca3af;
        }

        @keyframes pulse-ring {
            0% {
                transform: scale(0.95);
                box-shadow: 0 0 0 0 rgba(168, 85, 247, 0.7);
            }

            70% {
                transform: scale(1);
                box-shadow: 0 0 0 10px rgba(168, 85, 247, 0);
            }

            100% {
                transform: scale(0.95);
                box-shadow: 0 0 0 0 rgba(168, 85, 247, 0);
            }
        }

        .animate-pulse-ring {
            animation: pulse-ring 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
        }
    </style>
</head>

<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        const initialFlashcards = [
            {
                id: 1,
                category: "Core Concepts",
                front: "What is the definition of Concept Learning?",
                back: "It is the process of inducing general functions (like a Boolean decision function) from specific training examples (positive and negative)."
            },
            {
                id: 2,
                category: "Core Concepts",
                front: "What is the Inductive Learning Hypothesis?",
                back: "The assumption that any hypothesis that approximates the target function well over a large set of training examples will also approximate the target function well for unobserved (unseen) examples."
            },
            {
                id: 9,
                category: "ML Types",
                front: "What is the difference between Classification and Regression in supervised learning?",
                back: "Classification involves learning a discrete function (e.g., True/False), while regression involves learning a continuous function (e.g., predicting a number)."
            },
            {
                id: 10,
                category: "Core Concepts",
                front: "What is the Instance Space (X)?",
                back: "The set of all possible examples (e.g., all possible days described by the attributes), regardless of whether they are in the training set."
            },
            {
                id: 11,
                category: "Core Concepts",
                front: "What is the Hypothesis Space (H)?",
                back: "The set of all possible functions (hypotheses) that the learning algorithm can represent and search through to approximate the target concept."
            },
            {
                id: 3,
                category: "Core Concepts",
                front: "When is one hypothesis (h₂) considered 'more general' than another (h₁)?",
                back: "When h₂ classifies more instances as positive than h₁, and every instance classified as positive by h₁ is also classified as positive by h₂."
            },
            {
                id: 12,
                category: "Core Concepts",
                front: "The 'more general than' relation (≥g) creates what kind of mathematical structure in the hypothesis space?",
                back: "A partial order (or partially ordered set), which can be visualized as a lattice."
            },
            {
                id: 4,
                category: "Algorithms",
                front: "What is the specific goal of the Find-S algorithm?",
                back: "To find the most specific hypothesis in the hypothesis space (H) that is consistent with the training data."
            },
            {
                id: 8,
                category: "Algorithms",
                front: "In the Find-S algorithm, how do you handle a negative training example?",
                back: "You ignore it. Find-S only adjusts the hypothesis based on positive examples to make it just general enough to cover them."
            },
            {
                id: 5,
                category: "Algorithms",
                front: "What is a Version Space?",
                back: "The subset of the hypothesis space that contains all hypotheses consistent with the training data (both the specific and general boundaries)."
            },
            {
                id: 6,
                category: "Algorithms",
                front: "How does the Candidate Elimination algorithm represent the Version Space?",
                back: "It uses two boundary sets: G (The set of maximally general hypotheses consistent with the data) and S (The set of maximally specific hypotheses consistent with the data)."
            },
            {
                id: 13,
                category: "Algorithms",
                front: "In Candidate Elimination, how do positive examples affect the boundaries?",
                back: "They force the S (Specific) boundary to become more general."
            },
            {
                id: 14,
                category: "Algorithms",
                front: "In Candidate Elimination, how do negative examples affect the boundaries?",
                back: "They force the G (General) boundary to become more specific."
            },
            {
                id: 7,
                category: "Algorithms",
                front: "What are the two conditions required for Candidate Elimination to converge to the correct target concept?",
                back: "1. There are no errors (noise) in the training data.\n2. The target concept is actually contained within the hypothesis space (H)."
            }
        ];

        const FlashcardApp = () => {
            const [cards, setCards] = useState(initialFlashcards);
            const [currentIndex, setCurrentIndex] = useState(0);
            const [isFlipped, setIsFlipped] = useState(false);
            const [isGenerating, setIsGenerating] = useState(false);

            // Animation States: 'idle' | 'exiting-left' | 'exiting-right' | 'entering-from-right' | 'entering-from-left'
            const [animationState, setAnimationState] = useState('idle');
            const [isAnimating, setIsAnimating] = useState(false);

            // Swipe State
            const [touchStart, setTouchStart] = useState(null);
            const [touchEnd, setTouchEnd] = useState(null);
            const minSwipeDistance = 50;
            const swipeRef = useRef(false);

            const currentCard = cards[currentIndex];

            // Helper to handle transition delays
            const transitionDuration = 300;

            // --- API Integration ---
            const generateMoreCards = async () => {
                if (isGenerating) return;
                setIsGenerating(true);

                try {
                    const apiKey = ""; // Runtime provided
                    const prompt = `Generate 3 unique, advanced flashcards about Machine Learning Concept Learning, Find-S, and Candidate Elimination. Avoid duplicates of basic definitions. Return a strictly valid JSON array of objects. Each object must have keys: "category" (String: e.g. "Advanced Concept", "Algorithm Detail"), "front" (String), and "back" (String). Do not use markdown blocks, just raw JSON.`;

                    const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            contents: [{ parts: [{ text: prompt }] }]
                        })
                    });

                    const data = await response.json();
                    const text = data.candidates?.[0]?.content?.parts?.[0]?.text;

                    // Clean up markdown if present
                    const jsonStr = text.replace(/```json/g, '').replace(/```/g, '').trim();
                    const newCardsRaw = JSON.parse(jsonStr);

                    const maxId = Math.max(...cards.map(c => c.id));
                    const newCards = newCardsRaw.map((c, idx) => ({
                        ...c,
                        id: maxId + idx + 1
                    }));

                    setCards(prev => [...prev, ...newCards]);

                    // Show a quick success indication (could be a toast, here we just flip to the new cards potentially or stay put)
                    // Let's jump to the first new card
                    if (newCards.length > 0) {
                        // Optional: Navigate to the new card
                        // setCurrentIndex(cards.length); 
                    }

                } catch (error) {
                    console.error("Failed to generate cards:", error);
                    alert("Sorry, couldn't generate new cards right now.");
                } finally {
                    setIsGenerating(false);
                }
            };

            const handleNext = () => {
                if (isAnimating) return;
                setIsAnimating(true);

                // 1. Start Exit Animation
                setAnimationState('exiting-left');

                // 2. Wait for exit to finish
                setTimeout(() => {
                    setCurrentIndex((prev) => (prev + 1) % cards.length);
                    setIsFlipped(false);

                    // 3. Prepare Entry (move new card to start position instantly)
                    setAnimationState('entering-from-right');

                    // 4. Trigger Enter Animation (move to center)
                    requestAnimationFrame(() => {
                        requestAnimationFrame(() => {
                            setAnimationState('idle');
                            setTimeout(() => setIsAnimating(false), transitionDuration);
                        });
                    });
                }, transitionDuration);
            };

            const handlePrev = () => {
                if (isAnimating) return;
                setIsAnimating(true);

                // 1. Start Exit Animation
                setAnimationState('exiting-right');

                // 2. Wait for exit to finish
                setTimeout(() => {
                    setCurrentIndex((prev) => (prev - 1 + cards.length) % cards.length);
                    setIsFlipped(false);

                    // 3. Prepare Entry
                    setAnimationState('entering-from-left');

                    // 4. Trigger Enter Animation
                    requestAnimationFrame(() => {
                        requestAnimationFrame(() => {
                            setAnimationState('idle');
                            setTimeout(() => setIsAnimating(false), transitionDuration);
                        });
                    });
                }, transitionDuration);
            };

            const handleFlip = () => {
                if (!isAnimating) setIsFlipped(!isFlipped);
            };

            const handleCardClick = () => {
                if (!swipeRef.current && !isAnimating) {
                    handleFlip();
                }
                swipeRef.current = false;
            };

            const onTouchStart = (e) => {
                setTouchEnd(null);
                setTouchStart({ x: e.targetTouches[0].clientX, y: e.targetTouches[0].clientY });
                swipeRef.current = false;
            };

            const onTouchMove = (e) => {
                setTouchEnd({ x: e.targetTouches[0].clientX, y: e.targetTouches[0].clientY });
            };

            const onTouchEnd = () => {
                if (!touchStart || !touchEnd) return;

                const distanceX = touchStart.x - touchEnd.x;
                const distanceY = touchStart.y - touchEnd.y;
                const isHorizontal = Math.abs(distanceX) > Math.abs(distanceY);
                const isVertical = Math.abs(distanceY) > Math.abs(distanceX);

                if (isHorizontal && Math.abs(distanceX) > minSwipeDistance) {
                    swipeRef.current = true;
                    if (distanceX > 0) {
                        handleNext();
                    } else {
                        handlePrev();
                    }
                }
                else if (isVertical && Math.abs(distanceY) > minSwipeDistance) {
                    swipeRef.current = true;
                    handleFlip();
                }
            };

            const handleShuffle = () => {
                if (isAnimating) return;
                setIsAnimating(true);
                setAnimationState('exiting-left');
                setTimeout(() => {
                    setIsFlipped(false);
                    const shuffled = [...cards].sort(() => Math.random() - 0.5);
                    setCards(shuffled);
                    setCurrentIndex(0);
                    setAnimationState('entering-from-right');
                    requestAnimationFrame(() => {
                        setAnimationState('idle');
                        setTimeout(() => setIsAnimating(false), transitionDuration);
                    });
                }, transitionDuration);
            };

            const handleReset = () => {
                if (isAnimating) return;
                setIsAnimating(true);
                setAnimationState('exiting-left');
                setTimeout(() => {
                    setIsFlipped(false);
                    setCards(initialFlashcards);
                    setCurrentIndex(0);
                    setAnimationState('entering-from-right');
                    requestAnimationFrame(() => {
                        setAnimationState('idle');
                        setTimeout(() => setIsAnimating(false), transitionDuration);
                    });
                }, transitionDuration);
            };

            useEffect(() => {
                const handleKeyDown = (e) => {
                    if (isAnimating) return;
                    if (e.key === 'ArrowRight') handleNext();
                    if (e.key === 'ArrowLeft') handlePrev();
                    if (e.key === ' ' || e.key === 'Enter') handleFlip();
                };

                window.addEventListener('keydown', handleKeyDown);
                return () => window.removeEventListener('keydown', handleKeyDown);
            }, [cards.length, isAnimating]);

            // Icons
            const ChevronLeft = () => (
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="m15 18-6-6 6-6" /></svg>
            );

            const ChevronRight = () => (
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="m9 18 6-6-6-6" /></svg>
            );

            const RotateCw = () => (
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21 12a9 9 0 1 1-9-9c2.52 0 4.93 1 6.74 2.74L21 8" /><path d="M21 3v5h-5" /></svg>
            );

            const ShuffleIcon = () => (
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M2 18h1.4c1.3 0 2.5-.6 3.3-1.7l14.2-12.6c.8-1 2-1.7 3.3-1.7H22" /><path d="M2 6h1.4c1.3 0 2.5.6 3.3 1.7l14.2 12.6c.8 1 2 1.7 3.3 1.7H22" /></svg>
            );

            const SparklesIcon = () => (
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="m12 3-1.912 5.813a2 2 0 0 1-1.275 1.275L3 12l5.813 1.912a2 2 0 0 1 1.275 1.275L12 21l1.912-5.813a2 2 0 0 1 1.275-1.275L21 12l-5.813-1.912a2 2 0 0 1-1.275-1.275L12 3Z" /><path d="M5 3v4" /><path d="M9 3v4" /><path d="M3 5h4" /><path d="M3 9h4" /></svg>
            );

            const getCategoryColor = (cat) => {
                if (cat.toLowerCase().includes('algorithm')) return 'bg-purple-100 text-purple-800 border-purple-200';
                if (cat.toLowerCase().includes('concept')) return 'bg-blue-100 text-blue-800 border-blue-200';
                if (cat.toLowerCase().includes('ml types')) return 'bg-orange-100 text-orange-800 border-orange-200';
                return 'bg-emerald-100 text-emerald-800 border-emerald-200';
            };

            // Calculate Transforms based on Animation State
            const getCardTransformClass = () => {
                const base = "transition-all duration-300 ease-in-out";
                switch (animationState) {
                    case 'exiting-left': return `${base} -translate-x-[120%] opacity-0 scale-90 rotate-[-10deg]`;
                    case 'exiting-right': return `${base} translate-x-[120%] opacity-0 scale-90 rotate-[10deg]`;
                    case 'entering-from-right': return `translate-x-[120%] opacity-0 scale-90`;
                    case 'entering-from-left': return `-translate-x-[120%] opacity-0 scale-90`;
                    case 'idle': return `${base} translate-x-0 opacity-100 scale-100 rotate-0`;
                    default: return base;
                }
            };

            return (
                <div className="min-h-screen flex flex-col items-center justify-center p-4">

                    <div className="w-full max-w-2xl mb-8 text-center">
                        <h1 className="text-3xl font-bold text-gray-800 mb-2">Concept Learning Review</h1>
                        <p className="text-gray-600 flex items-center justify-center gap-2">
                            <span>Tap or Swipe ↕ to flip</span>
                            <span className="text-gray-300">•</span>
                            <span>Swipe ↔ to navigate</span>
                        </p>
                    </div>

                    {/* Main Card Container */}
                    <div
                        className="perspective-1000 w-full max-w-xl h-80 cursor-pointer group no-select relative z-0"
                        onClick={handleCardClick}
                        onTouchStart={onTouchStart}
                        onTouchMove={onTouchMove}
                        onTouchEnd={onTouchEnd}
                        style={{ touchAction: 'none' }}
                    >
                        {/* Stack Effect Layers */}
                        <div className="absolute top-0 left-0 w-full h-full bg-white rounded-2xl border border-gray-200 shadow-sm transform translate-y-6 translate-x-4 rotate-2 scale-[0.92] -z-20 opacity-40 transition-all duration-300"></div>
                        <div className="absolute top-0 left-0 w-full h-full bg-white rounded-2xl border border-gray-200 shadow-sm transform translate-y-3 translate-x-2 rotate-1 scale-[0.96] -z-10 opacity-70 transition-all duration-300"></div>

                        {/* Active Card - NOW WITH transform-style-3d to fix nested flip */}
                        <div className={`w-full h-full transform-style-3d ${getCardTransformClass()}`}>
                            <div className={`relative w-full h-full duration-500 transform-style-3d transition-transform ${isFlipped ? 'rotate-y-180' : ''}`}>

                                {/* Front Face */}
                                <div className="absolute w-full h-full backface-hidden bg-white rounded-2xl shadow-xl border border-gray-100 flex flex-col overflow-hidden">
                                    <div className="h-2 w-full bg-gradient-to-r from-blue-500 to-purple-600"></div>
                                    <div className="flex-1 flex flex-col items-center justify-center p-8 text-center">
                                        <span className={`px-3 py-1 rounded-full text-xs font-semibold mb-6 border ${getCategoryColor(currentCard.category)}`}>
                                            {currentCard.category}
                                        </span>
                                        <h2 className="text-2xl font-semibold text-gray-800 leading-relaxed">
                                            {currentCard.front}
                                        </h2>
                                        <p className="mt-8 text-sm text-gray-400 font-medium uppercase tracking-wider">Tap to Flip</p>
                                    </div>
                                </div>

                                {/* Back Face */}
                                <div className="absolute w-full h-full backface-hidden rotate-y-180 bg-white rounded-2xl shadow-xl border border-gray-100 flex flex-col overflow-hidden">
                                    <div className="h-2 w-full bg-gradient-to-r from-purple-600 to-blue-500"></div>
                                    <div className="flex-1 flex flex-col items-center justify-center p-8 text-center card-content overflow-y-auto">
                                        <span className="text-sm text-gray-400 font-medium uppercase tracking-wider mb-4">Answer</span>
                                        <p className="text-xl text-gray-700 leading-relaxed whitespace-pre-line">
                                            {currentCard.back}
                                        </p>
                                    </div>
                                </div>

                            </div>
                        </div>
                    </div>

                    {/* Controls */}
                    <div className="flex items-center gap-6 mt-10">
                        <button
                            onClick={(e) => { e.stopPropagation(); handlePrev(); }}
                            disabled={isAnimating}
                            className="p-3 rounded-full bg-white shadow-md hover:bg-gray-50 text-gray-700 transition-transform active:scale-95 border border-gray-200 disabled:opacity-50"
                            aria-label="Previous card"
                        >
                            <ChevronLeft />
                        </button>

                        <div className="text-gray-500 font-medium font-mono">
                            {currentIndex + 1} / {cards.length}
                        </div>

                        <button
                            onClick={(e) => { e.stopPropagation(); handleNext(); }}
                            disabled={isAnimating}
                            className="p-3 rounded-full bg-white shadow-md hover:bg-gray-50 text-gray-700 transition-transform active:scale-95 border border-gray-200 disabled:opacity-50"
                            aria-label="Next card"
                        >
                            <ChevronRight />
                        </button>
                    </div>

                    {/* Secondary Actions */}
                    <div className="flex flex-wrap justify-center gap-4 mt-8 w-full max-w-xl">
                        <button
                            onClick={generateMoreCards}
                            disabled={isGenerating || isAnimating}
                            className={`flex items-center gap-2 px-5 py-2.5 rounded-lg bg-gradient-to-r from-purple-600 to-blue-600 text-white text-sm font-semibold hover:from-purple-700 hover:to-blue-700 transition-all shadow-md active:scale-95 disabled:opacity-70 ${isGenerating ? 'animate-pulse' : ''}`}
                        >
                            {isGenerating ? (
                                <>Generating...</>
                            ) : (
                                <><SparklesIcon /> Generate More</>
                            )}
                        </button>

                        <button
                            onClick={handleShuffle}
                            disabled={isAnimating}
                            className="flex items-center gap-2 px-4 py-2 rounded-lg bg-white border border-gray-200 text-gray-600 text-sm font-medium hover:bg-gray-50 transition-colors shadow-sm disabled:opacity-50"
                        >
                            <ShuffleIcon /> Shuffle
                        </button>
                        <button
                            onClick={handleReset}
                            disabled={isAnimating}
                            className="flex items-center gap-2 px-4 py-2 rounded-lg bg-white border border-gray-200 text-gray-600 text-sm font-medium hover:bg-gray-50 transition-colors shadow-sm disabled:opacity-50"
                        >
                            <RotateCw /> Reset
                        </button>
                    </div>

                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<FlashcardApp />);
    </script>
</body>

</html>